<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Homework 3 - Statistics - Gaia Diodati</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;600&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');

    body {
      margin: 0;
      font-family: 'Rajdhani', sans-serif;
      color: #fff5cc;
      background: #050505;
      overflow-x: hidden;
    }

    canvas#bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .hero {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 0 4vw;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(2.2rem, 8vw, 5rem);
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #e6b800;
      position: relative;
      text-shadow: 0 0 8px #ffcc00, 0 0 16px #ffaa00, 2px 2px 35px rgba(255,200,0,0.8);
      animation: glowPulse 4s ease-in-out infinite, glitch 2s infinite;
      margin: 0 0 12px;
    }

    h1::before, h1::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      color: #ffaa00;
      background: transparent;
      overflow: hidden;
    }

    h1::before {
      left: 2px;
      text-shadow: -2px 0 #ff33cc;
      animation: glitchShift 2s infinite linear alternate-reverse;
    }

    h1::after {
      left: -2px;
      text-shadow: 2px 0 #00ffcc;
      animation: glitchShift 3s infinite linear alternate;
    }

    h2 {
      font-size: clamp(1.2rem, 4vw, 2rem);
      color: #ffd966;
      margin: 6px 0;
    }
    
    /* Specific H2 style for post-card */
    .post-card h2 {
      font-family: 'Orbitron', sans-serif;
      color: #ffaa00;
      margin-bottom: 10px;
      font-size: clamp(1.2rem, 4vw, 1.6rem);
    }

    .subtitle {
      font-size: clamp(0.9rem, 3vw, 1rem);
      color: #fff3cc;
      opacity: 0.9;
      line-height: 1.5;
    }

    @keyframes glitchShift {
      0% { clip-path: inset(0 0 90% 0); }
      20% { clip-path: inset(10% 0 70% 0); }
      40% { clip-path: inset(40% 0 30% 0); }
      60% { clip-path: inset(60% 0 10% 0); }
      80% { clip-path: inset(80% 0 0 0); }
      100% { clip-path: inset(0 0 100% 0); }
    }

    @keyframes glowPulse {
      0%, 100% { text-shadow: 0 0 8px #ffcc00, 0 0 20px #ffaa00, 0 0 40px #ffcc33; }
      50% { text-shadow: 0 0 15px #ffee88, 0 0 35px #ffaa00, 0 0 60px #ffd966; }
    }

    @keyframes glitch {
      0%, 100% { transform: none; }
      92% { transform: translate(-1px, 1px) skew(0.3deg); }
      94% { transform: translate(1px, -1px) skew(-0.3deg); }
      96% { transform: translate(-2px, 1px) skew(0.5deg); }
      98% { transform: translate(2px, -1px) skew(-0.5deg); }
    }

    .posts {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 50px 5vw 70px;
      gap: 25px;
      background: rgba(20, 20, 20, 0.8);
    }

    .post-card {
      width: 90%;
      max-width: 700px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 200, 0, 0.3);
      border-radius: 12px;
      padding: 22px;
      text-align: left;
      backdrop-filter: blur(6px);
      transition: all 0.3s ease;
    }

    .post-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 0 25px rgba(255, 200, 0, 0.3);
    }

    .post-card p {
      color: #fff3cc;
      font-size: clamp(0.9rem, 2.8vw, 1rem);
      line-height: 1.6;
      margin-bottom: 12px;
    }
    
    .post-card ul, .post-card ol {
        color: #fff3cc;
        font-size: clamp(0.9rem, 2.8vw, 1rem);
        line-height: 1.6;
        margin-left: 20px;
        margin-bottom: 12px;
    }
    .post-card li {
        margin-bottom: 8px;
    }
    
    .post-card p code, .post-card li code {
        color: #ffcc00;
        background: rgba(0,0,0,0.2);
        padding: 2px 5px;
        border-radius: 4px;
        font-family: 'Roboto Mono', monospace;
    }

    .post-card a {
      display: inline-block;
      margin-top: 12px;
      color: #ffaa00;
      text-decoration: none;
      border: 1px solid #ffaa00;
      padding: 7px 14px;
      border-radius: 999px;
      font-size: clamp(0.85rem, 3vw, 1rem);
      transition: all 0.3s ease;
    }

    .post-card a:hover {
      background: #ffaa00;
      color: #000;
    }
    
    /* --- START SIMULATION STYLES --- */
    
    .post-card label {
      display: block;
      font-family: 'Orbitron', sans-serif;
      color: #ffaa00;
      margin-bottom: 8px;
      font-size: 0.9rem;
    }
    
    .post-card input[type="number"],
    .post-card textarea {
      width: 100%;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255, 200, 0, 0.3);
      color: #fff3cc;
      padding: 10px;
      border-radius: 8px;
      font-family: 'Rajdhani', sans-serif;
      font-size: 1rem;
      margin-bottom: 12px;
      box-sizing: border-box;
    }
    
    .post-card textarea {
      min-height: 120px;
      font-family: 'Roboto Mono', monospace;
    }
    
    .post-card button {
      display: inline-block;
      width: 100%;
      margin-top: 12px;
      margin-bottom: 12px;
      color: #ffaa00;
      text-decoration: none;
      border: 1px solid #ffaa00;
      background: transparent;
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 1rem;
      font-family: 'Orbitron', sans-serif;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .post-card button:hover {
      background: #ffaa00;
      color: #000;
    }
    
    /* Read-only element styles */
    .post-card textarea:read-only {
      background: rgba(0,0,0,0.5);
      cursor: not-allowed;
      color: #aaa;
    }
    
    #decryptedText {
        color: #34d399; /* Green for success */
        font-weight: bold;
    }
    
    #analysisResult {
        background: rgba(0,0,0,0.3);
        border: 1px solid rgba(255, 200, 0, 0.3);
        padding: 12px;
        border-radius: 8px;
        min-height: 100px;
        font-size: 0.9rem;
        line-height: 1.5;
        font-family: 'Roboto Mono', monospace;
    }
    
    /* Grid for p, q, e inputs */
    .grid-3-col {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 15px;
    }
    
    /* Responsive grid for mobile */
    @media (max-width: 600px) {
        .grid-3-col {
            grid-template-columns: 1fr;
        }
    }
    
    /* Styles for the C code block */
    .code-block {
      background-color: rgba(0,0,0,0.4);
      border: 1px solid rgba(255, 200, 0, 0.3);
      border-radius: 8px;
      padding: 1.5rem;
      margin-top: 1rem;
      overflow-x: auto;
      color: #d1d5db;
    }
    .code-block pre {
      margin: 0;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.9em;
      line-height: 1.5;
    }
    .code-block .comment { color: #888; }
    .code-block .keyword { color: #ffaa00; }
    .code-block .function { color: #34d399; }
    .code-block .string { color: #ffd966; }
    .code-block .number { color: #60a5fa; }
    /* --- END SIMULATION STYLES --- */
    
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <div class="hero">
    <h1 data-text="Homework 3">Homework 3</h1>
    <h2>RSA Encryption & Frequency Analysis</h2>
    <p class="subtitle">Gaia Diodati – Matricola 2279030<br>Master's Degree in Cyber Security – Sapienza University</p>
  </div>

  <section class="posts">
    
    <div class="post-card">
      <h2>What is Asymmetric (Public-Key) Cryptography?</h2>
      <p>Unlike the Caesar cipher (<strong>symmetric</strong> cryptography), asymmetric cryptography uses a pair of keys:</p>
      <ul>
        <li><strong>Public Key:</strong> Can be shared with anyone. Used to <strong>encrypt</strong> messages.</li>
        <li><strong>Private Key:</strong> Must be kept secret. It's the only key that can <strong>decrypt</strong> messages encrypted with its corresponding public key.</li>
      </ul>
      <p>This solves a huge problem: how to securely exchange a secret key? With RSA, it's unnecessary. You can publish your public key, and anyone can send you a secure message.</p>
      
      <h2>The RSA Algorithm: Overview</h2>
      <p>RSA (named after its inventors, Rivest, Shamir, and Adleman) bases its security on the difficulty of factoring very large numbers. The key steps are:</p>
      <ol>
        <li><strong>Key Generation:</strong>
          <ul>
            <li>Choose two very large prime numbers, <code>p</code> and <code>q</code> (secret).</li>
            <li>Calculate the modulus <code>n = p * q</code> (public).</li>
            <li>Calculate Euler's totient function <code>phi(n) = (p-1) * (q-1)</code> (secret).</li>
            <li>Choose a public exponent <code>e</code> (often 65537 or 3), which must be coprime with <code>phi(n)</code>.</li>
            <li>Calculate the private exponent <code>d</code> such that <code>(d * e) % phi(n) = 1</code>.</li>
          </ul>
        </li>
        <li><strong>Encryption:</strong> To encrypt a message <code>M</code> (treated as a number), calculate: <code>C = (M^e) % n</code>.</li>
        <li><strong>Decryption:</strong> To decrypt <code>C</code>, calculate: <code>M = (C^d) % n</code>.</li>
      </ol>
    </div>
    
    <div class="post-card">
      <h2>The Homework Premise: "Letter-by-Letter" RSA</h2>
      <p>Normally, RSA encrypts large blocks of data. For this assignment, we apply the RSA formula to every single character (or, more precisely, its ASCII value). For example, we encrypt 'a' (ASCII 97), then 'b' (ASCII 98), and so on.</p>
      <p>This creates a <strong>homophonic substitution cipher</strong>. Every 'a' in the original text will always be encrypted into the same number (<code>97^e % n</code>), and every 'b' will be encrypted into another fixed number (<code>98^e % n</code>). What does this mean from a statistical point of view?</p>
      <p>It means that the **frequency distribution is preserved!** Just like in the Caesar cipher, the most frequent letter in the plaintext (like 'e' or 'a') will correspond to the most frequent *number* in the ciphertext. This is a fatal vulnerability that allows us to use the same frequency analysis from the previous assignment to break this flawed implementation of RSA.</p>
      
      <h2>From Statistics to Cryptanalysis</h2>
      <p>Since the frequency is preserved, we can launch an attack. If we have a ciphertext (a long list of numbers), we can:</p>
      <ol>
        <li>Count the frequency of each number in the ciphertext.</li>
        <li>Count the frequency of each letter in a reference text (e.g., a long text in Italian or English).</li>
        <li>Create a decryption map: The most frequent number in the ciphertext *probably* corresponds to the most frequent letter in the reference text. The second most frequent corresponds to the second, and so on.</li>
      </ol>
    </div>

    <div class="post-card">
      <h2>RSA Simulation and Frequency Attack</h2>
      <p>This simulation encrypts the text using the RSA formula on each character, then uses frequency analysis to deduce the original text.</p>
      
      <div id="simulation-section" style="margin-top: 20px;">
        <div class="space-y-4">
          <div>
            <label for="inputText">1. Enter Original Text (the longer, the better):</label>
            <textarea id="inputText" rows="5">Statistics is the grammar of science. It allows us to understand the language of data, transforming uncertainty into knowledge and guiding our decisions with logic and rigor. Using statistical methods to analyze patterns is fundamental. In cryptography, frequency analysis is a classic example of how statistics can reveal hidden secrets in a ciphertext, especially in simple substitution ciphers like the Caesar cipher. The letters 'e' and 't' are very common in English.</textarea>
          </div>
          
          <div class="grid-3-col">
            <div>
              <label for="rsaP">2. Prime `p` (e.g., 53):</label>
              <input type="number" id="rsaP" value="53">
            </div>
            <div>
              <label for="rsaQ">3. Prime `q` (e.g., 59):</label>
              <input type="number" id="rsaQ" value="59">
            </div>
            <div>
              <label for="rsaE">4. Exponent `e` (e.g., 3):</label>
              <input type="number" id="rsaE" value="3">
            </div>
          </div>
          
          <div>
            <button id="runSimulationBtn">5. Encrypt & Run Analysis</button>
          </div>
          
          <hr style="border-color: rgba(255, 200, 0, 0.3); margin: 20px 0;">

          <div>
            <label>6. Encrypted Text (Numerical Values):</label>
            <textarea id="encryptedText" rows="5" readonly></textarea>
          </div>
          
          <div>
            <h4 style="font-family: 'Orbitron', sans-serif; color: #ffaa00; margin-bottom: 10px; font-size: 1.1rem;">Frequency Distribution (Ranked):</h4>
            <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px;">
              <canvas id="freqChart"></canvas>
            </div>
          </div>
          
            <div>
            <label>7. Analysis & Calculated Keys:</label>
            <div id="analysisResult">Analysis will appear here...</div>
          </div>
          
          <div>
            <label>8. Decrypted Text (via Statistical Analysis):</label>
            <textarea id="decryptedText" rows="5" readonly></textarea>
          </div>
        </div>
      </div>
    </div>
    
    <div class="post-card">
      <h2>Correct RSA Implementation in C</h2>
      <p>The simulation above demonstrates the required "letter-by-letter" approach and its attack. However, it's important to see how RSA is implemented *correctly*. The following C program implements the RSA algorithm to encrypt and decrypt a *single number* (which would practically represent an entire block of text), not individual letters. This approach is secure against frequency analysis.</p>

      <div class="code-block">
          <pre><code><span class="comment">// Include standard I/O and math for the pow function</span>
<span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;math.h&gt;</span>

<span class="comment">// Data type for large numbers (long long)</span>
<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;

<span class="comment">// Function to efficiently calculate (base^exp) % mod</span>
ll <span class="function">pow_mod</span>(ll base, ll exp, ll mod) {
    ll res = <span class="number">1</span>;
    base %= mod;
    <span class="keyword">while</span> (exp > <span class="number">0</span>) {
        <span class="keyword">if</span> (exp % <span class="number">2</span> == <span class="number">1</span>) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= <span class="number">2</span>;
    }
    <span class="keyword">return</span> res;
}

<span class="comment">// Function to find the modular inverse of 'a' modulo 'm'</span>
<span class="comment">// Finds 'x' such that (a*x) % m = 1</span>
ll <span class="function">mod_inverse</span>(ll a, ll m) {
    a = a % m;
    <span class="keyword">for</span> (ll x = <span class="number">1</span>; x < m; x++) {
        <span class="keyword">if</span> ((a * x) % m == <span class="number">1</span>) {
            <span class="keyword">return</span> x;
        }
    }
    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// Not found (shouldn't happen if a and m are coprime)</span>
}

<span class="keyword">int</span> <span class="function">main</span>(<span class="keyword">void</span>) {
    <span class="comment">// 1. Key Generation (with small primes for example)</span>
    ll p = <span class="number">53</span>;
    ll q = <span class="number">59</span>;
    ll e = <span class="number">3</span>; <span class="comment">// A common public exponent</span>

    ll n = p * q;
    ll phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>);
    
    <span class="comment">// Calculate the private key 'd'</span>
    ll d = <span class="function">mod_inverse</span>(e, phi_n);

    <span class="function">printf</span>(<span class="string">"--- RSA Parameters ---\n"</span>);
    <span class="function">printf</span>(<span class="string">"p = %lld, q = %lld, e = %lld\n"</span>, p, q, e);
    <span class="function">printf</span>(<span class="string">"Public Key (n, e): (%lld, %lld)\n"</span>, n, e);
    <span class="function">printf</span>(<span class="string">"Phi(n) = %lld\n"</span>, phi_n);
    <span class="function">printf</span>(<span class="string">"Private Key (d): %lld\n"</span>, d);
    
    <span class="comment">// Message to encrypt (as a number)</span>
    <span class="comment">// Must be less than 'n'</span>
    ll message = <span class="number">888</span>;

    <span class="function">printf</span>(<span class="string">"\n--- Process ---\n"</span>);
    <span class="function">printf</span>(<span class="string">"Original Message (M): %lld\n"</span>, message);

    <span class="comment">// 2. Encryption: C = (M^e) % n</span>
    ll encrypted = <span class="function">pow_mod</span>(message, e, n);
    <span class="function">printf</span>(<span class="string">"Encrypted (C): %lld\n"</span>, encrypted);

    <span class="comment">// 3. Decryption: M = (C^d) % n</span>
    ll decrypted = <span class="function">pow_mod</span>(encrypted, d, n);
    <span class="function">printf</span>(<span class="string">"Decrypted (M'): %lld\n"</span>, decrypted);

    <span class="comment">// Verification</span>
    <span class="keyword">if</span> (message == decrypted) {
        <span class="function">printf</span>(<span class="string">"\nSuccess: Message recovered!\n"</span>);
    } <span class="keyword">else</span> {
        <span class="function">printf</span>(<span class="string">"\nError: Decryption failed.\n"</span>);
    }
    
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
      </div>
    </div>
    
    <div class="post-card">
      <h2>Conclusion: Why the Flawed Implementation is Insecure</h2>
      <p>As you can see, the correct implementation of RSA is mathematically intensive and operates on numbers, not letters. Its security stems from the difficulty of finding <code>d</code> given only <code>n</code> and <code>e</code>, which would require factoring <code>n</code> into its prime components <code>p</code> and <code>q</code>—an extremely difficult operation for very large numbers.</p>
      <p>The vulnerability we exploited in the simulation is not a weakness of RSA itself, but a weakness of the **implementation**. Applying any deterministic cipher (where 'a' *always* becomes 'x') "letter-by-letter" will always create a substitution cipher, which is immediately vulnerable to frequency analysis, as we have demonstrated.</p>
      <p>In the real world, RSA is never used this way. It's used with **padding schemes** (like OAEP), which add random data to each block before encryption. This ensures that even encrypting the same letter twice will produce two different ciphertexts, making frequency analysis impossible.</p>
      <a href="index.html">← Back to Index</a>
    </div>
  </section>

  <script>
    // --- SCRIPT 1: Canvas Background Animation ---
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const points = [];
    const numPoints = 100;

    for (let i = 0; i < numPoints; i++) {
      points.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.6,
        vy: (Math.random() - 0.5) * 0.6
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        for (let j = i + 1; j < points.length; j++) {
          const p2 = points[j];
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 130) {
            ctx.strokeStyle = `rgba(255, 200, 0, ${(1 - dist / 130) * 0.15})`;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }

        p1.x += p1.vx;
        p1.y += p1.vy;
        if (p1.x < 0 || p1.x > canvas.width) p1.vx *= -1;
        if (p1.y < 0 || p1.y > canvas.height) p1.vy *= -1;

        ctx.beginPath();
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#ffcc00';
        ctx.fill();
      }
      requestAnimationFrame(draw);
    }
    draw();
    
    // --- SCRIPT 2: RSA Simulation Logic ---
    document.addEventListener('DOMContentLoaded', () => {

        // --- DOM Elements for RSA Simulation ---
        const inputTextEl = document.getElementById('inputText');
        const rsaPEl = document.getElementById('rsaP');
        const rsaQEl = document.getElementById('rsaQ');
        const rsaEEl = document.getElementById('rsaE');
        const runBtn = document.getElementById('runSimulationBtn');
        const encryptedTextEl = document.getElementById('encryptedText');
        const decryptedTextEl = document.getElementById('decryptedText');
        const analysisResultEl = document.getElementById('analysisResult');
        const freqChartCanvas = document.getElementById('freqChart');
        let freqChart = null;

        // --- Mathematical Functions for RSA (using BigInt) ---

        // Calculates (base^exp) % mod for BigInt
        function powMod(base, exp, mod) {
            base = BigInt(base);
            exp = BigInt(exp);
            mod = BigInt(mod);
            if (mod === 0n) throw new Error("Cannot take modulo of zero");
            
            let result = 1n;
            base = base % mod;
            
            while (exp > 0n) {
                if (exp % 2n === 1n) { // If exponent is odd
                    result = (result * base) % mod;
                }
                exp = exp >> 1n; // Divide exponent by 2
                base = (base * base) % mod; // Square the base
            }
            return result;
        }

        // Greatest Common Divisor
        function gcd(a, b) {
            a = BigInt(a);
            b = BigInt(b);
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        
        // Modular Inverse (using the extended Euclidean algorithm)
        function modInverse(a, m) {
            a = BigInt(a);
            m = BigInt(m);
            const m0 = m;
            let y = 0n, x = 1n;

            if (m === 1n) return 0n;

            while (a > 1n) {
                const q = a / m;
                let t = m;
                m = a % m;
                a = t;
                t = y;
                y = x - q * y;
                x = t;
            }
            if (x < 0n) x += m0;
            return x;
        }

        // --- Statistical Analysis Functions ---

        const getCharFrequency = (text) => {
            const freqMap = new Map();
            // Only lowercase a-z for simplicity
            const sanitizedText = text.toLowerCase().replace(/[^a-z]/g, ''); 
            for (const char of sanitizedText) {
                freqMap.set(char, (freqMap.get(char) || 0) + 1);
            }
            // Sort by frequency (descending)
            return new Map([...freqMap.entries()].sort((a, b) => b[1] - a[1]));
        };

        const updateFreqChart = (originalSortedFreq, cipherSortedFreq) => {
            const originalCounts = [...originalSortedFreq.values()];
            const cipherCounts = [...cipherSortedFreq.values()];

            const count = Math.min(originalCounts.length, cipherCounts.length, 26);
            const labels = Array.from({length: count}, (_, i) => `Rank ${i + 1}`);
            
            const chartData = {
                labels: labels,
                datasets: [
                    {
                        label: 'Original Text Freq. (Ranked)',
                        data: originalCounts.slice(0, count),
                        backgroundColor: 'rgba(255, 170, 0, 0.6)', // Color #ffaa00
                        borderColor: 'rgba(255, 170, 0, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Ciphertext Freq. (Ranked)',
                        data: cipherCounts.slice(0, count),
                        backgroundColor: 'rgba(0, 255, 204, 0.6)', // Color #00ffcc
                        borderColor: 'rgba(0, 255, 204, 1)',
                        borderWidth: 1
                    }
                ]
            };

            if (freqChart) {
                freqChart.data = chartData;
                freqChart.update();
            } else {
                freqChart = new Chart(freqChartCanvas, {
                    type: 'bar',
                    data: chartData,
                    options: {
                        responsive: true,
                        animation: {
                            duration: 800,
                            easing: 'easeInOutQuart',
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#fff3cc' },
                                grid: { color: 'rgba(255, 200, 0, 0.15)' }
                            },
                            x: {
                                ticks: { color: '#fff3cc' },
                                grid: { color: 'rgba(255, 200, 0, 0.15)' }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: { color: '#fff3cc' }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        const origChar = [...originalSortedFreq.keys()][index];
                                        const cipherNum = [...cipherSortedFreq.keys()][index];
                                        return `Rank ${index + 1}: Map '${origChar}' <-> ${cipherNum}`;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        };

        const runSimulation = () => {
            try {
                const p = BigInt(rsaPEl.value);
                const q = BigInt(rsaQEl.value);
                const e = BigInt(rsaEEl.value);
                const originalText = inputTextEl.value;

                // --- 1. RSA Key Calculation ---
                const n = p * q;
                const phi = (p - 1n) * (q - 1n);

                if (gcd(e, phi) !== 1n) {
                    analysisResultEl.innerHTML = `<span style="color: #ff6b6b;">Error: 'e' (${e}) is not coprime with phi (${phi}). Choose another 'e'.</span>`;
                    return;
                }
                
                // We calculate 'd' (private key) only to show it.
                // The attack won't use it.
                const d = modInverse(e, phi);

                analysisResultEl.innerHTML = `Calculated Parameters:<br>` +
                                             `&nbsp; <b style="color: #ffaa00;">n (Modulus)</b>: ${n}<br>` +
                                             `&nbsp; <b style="color: #ffaa00;">phi(n)</b>: ${phi}<br>` +
                                             `&nbsp; <b style="color: #ffaa00;">Public Key (e)</b>: ${e}<br>` +
                                             `&nbsp; <b style="color: #ffaa00;">Private Key (d)</b>: ${d} <span style="color: #888;">(reference)</span>`;

                // --- 2. "Letter-by-Letter" Encryption ---
                const encryptedData = [];
                for (let i = 0; i < originalText.length; i++) {
                    const char = originalText[i];
                    const m = BigInt(char.charCodeAt(0)); // Use ASCII value
                    const c = powMod(m, e, n);
                    encryptedData.push(c);
                }
                encryptedTextEl.value = encryptedData.join(' ');
                
                // --- 3. Frequency Analysis (The Attack) ---

                // Frequency of the original text (only a-z for the attack)
                const originalFreqSorted = getCharFrequency(originalText);
                
                // Frequency of the ciphertext (only for encrypted letters)
                const cipherFreqMap = new Map();
                for (let i = 0; i < originalText.length; i++) {
                    const char = originalText[i].toLowerCase();
                    if (char >= 'a' && char <= 'z') { // Only attack letters
                        const cipherNumStr = encryptedData[i].toString();
                        cipherFreqMap.set(cipherNumStr, (cipherFreqMap.get(cipherNumStr) || 0) + 1);
                    }
                }
                const cipherFreqSorted = new Map([...cipherFreqMap.entries()].sort((a, b) => b[1] - a[1]));

                // Update the chart
                updateFreqChart(originalFreqSorted, cipherFreqSorted);

                // --- 4. Build Decryption Map (Attack) ---
                
                // Build a complete "translation" map based on frequency
                // for all characters (including spaces, punctuation, etc.)
                const origFreqAll = new Map();
                const cipherFreqAll = new Map();
                
                for (let i = 0; i < originalText.length; i++) {
                    const char = originalText[i];
                    const numStr = encryptedData[i].toString();
                    origFreqAll.set(char, (origFreqAll.get(char) || 0) + 1);
                    cipherFreqAll.set(numStr, (cipherFreqAll.get(numStr) || 0) + 1);
                }
                
                const sortedOrigAll = [...origFreqAll.entries()].sort((a, b) => b[1] - a[1]);
                const sortedCipherAll = [...cipherFreqAll.entries()].sort((a, b) => b[1] - a[1]);

                let mapReport = "Decryption Map Construction (Attack):<br>";
                const finalAttackMap = new Map();
                for (let i = 0; i < sortedOrigAll.length; i++) {
                    if (sortedCipherAll[i]) {
                        const plainChar = sortedOrigAll[i][0];
                        const cipherNum = sortedCipherAll[i][0];
                        finalAttackMap.set(cipherNum, plainChar);
                        if (i < 5) { // Show only the first 5 mappings
                             mapReport += `&nbsp; ${i+1}. Cipher Num <b style="color: #ffaa00;">${cipherNum}</b> (Freq: ${sortedCipherAll[i][1]}) -> Char <b style="color: #ffaa00;">'${plainChar}'</b> (Freq: ${sortedOrigAll[i][1]})<br>`;
                        }
                    }
                }
                analysisResultEl.innerHTML += "<br><br>" + mapReport;

                // --- 5. Decryption (Attack) ---
                let decryptedText = "";
                for (const c of encryptedData) {
                    const char = finalAttackMap.get(c.toString());
                    decryptedText += char || '?'; // Use '?' if not found
                }
                decryptedTextEl.value = decryptedText;


            } catch (err) {
                analysisResultEl.innerHTML = `<span style="color: #ff6b6b;">Error: ${err.message}. Ensure p and q are primes.</span>`;
            }
        };

        runBtn.addEventListener('click', runSimulation);
        runSimulation(); // Run on page load
    });
  </script>
</body>
</html>