<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Homework 11 - The Wiener Process & Stochastic Calculus - Gaia Diodati</title>
  
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  
  <script>
      MathJax = {
          tex: {
              inlineMath: [['$', '$'], ['\\(', '\\)']] 
          }
      };
  </script>
  
  <style>
    /* Global Styles */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@400;600&display=swap');

    body {
      margin: 0;
      font-family: 'Rajdhani', sans-serif;
      color: #fff5cc;
      background: #050505;
      overflow-x: hidden;
    }
    
    canvas#bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .hero {
      min-height: 50vh; 
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 0 4vw;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(2.2rem, 8vw, 5rem);
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #e6b800;
      position: relative;
      text-shadow: 0 0 8px #ffcc00, 0 0 16px #ffaa00, 2px 2px 35px rgba(255,200,0,0.8);
      animation: glowPulse 4s ease-in-out infinite, glitch 2s infinite;
      margin: 0 0 12px;
    }

    h1::before, h1::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      color: #ffaa00;
      background: transparent;
      overflow: hidden;
    }

    h1::before { left: 2px; text-shadow: -2px 0 #ff33cc; animation: glitchShift 2s infinite linear alternate-reverse; }
    h1::after { left: -2px; text-shadow: 2px 0 #00ffcc; animation: glitchShift 3s infinite linear alternate; }

    h2 { font-size: clamp(1.2rem, 4vw, 2rem); color: #ffd966; margin: 6px 0; }
    .subtitle { font-size: clamp(0.9rem, 3vw, 1rem); color: #fff3cc; opacity: 0.9; line-height: 1.5; }
    
    @keyframes glitchShift {
      0% { clip-path: inset(0 0 90% 0); } 20% { clip-path: inset(10% 0 70% 0); }
      40% { clip-path: inset(40% 0 30% 0); } 60% { clip-path: inset(60% 0 10% 0); }
      80% { clip-path: inset(80% 0 0 0); } 100% { clip-path: inset(0 0 100% 0); }
    }
    @keyframes glowPulse {
      0%, 100% { text-shadow: 0 0 8px #ffcc00, 0 0 20px #ffaa00, 0 0 40px #ffcc33; }
      50% { text-shadow: 0 0 15px #ffee88, 0 0 35px #ffaa00, 0 0 60px #ffd966; }
    }
    @keyframes glitch {
      0%, 100% { transform: none; }
      92% { transform: translate(-1px, 1px) skew(0.3deg); } 94% { transform: translate(1px, -1px) skew(-0.3deg); }
      96% { transform: translate(-2px, 1px) skew(0.5deg); } 98% { transform: translate(2px, -1px) skew(-0.5deg); }
    }

    /* Content Styling */
    .content-section {
        padding: 50px 5vw 70px;
        background: rgba(20, 20, 20, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
    }

    .post-card {
        width: 90%;
        max-width: 900px; 
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 200, 0, 0.3);
        border-radius: 12px;
        padding: 22px;
        text-align: left;
        backdrop-filter: blur(6px);
    }
    
    .post-card h3 {
        font-family: 'Orbitron', sans-serif;
        color: #ffd966;
        margin-top: 25px;
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(255, 200, 0, 0.2);
        padding-bottom: 5px;
        font-size: clamp(1.1rem, 3.5vw, 1.4rem);
    }
    .post-card p, .post-card ul, .post-card ol {
        color: #fff3cc;
        font-size: clamp(0.9rem, 2.8vw, 1rem);
        line-height: 1.6;
        margin-bottom: 15px;
    }
    
    .key-definition { font-style: italic; color: #fff; font-weight: 600; }

    /* Controls & Chart */
    .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
        justify-content: center;
        align-items: flex-end;
    }
    .control-group { display: flex; flex-direction: column; gap: 5px; }
    .controls label { color: #00ffcc; font-family: 'Orbitron', sans-serif; font-size: 0.9rem; }
    .controls input {
        background: rgba(0, 0, 0, 0.5); border: 1px solid #ffaa00; color: #fff;
        padding: 10px; border-radius: 5px; font-family: 'Rajdhani', sans-serif; font-size: 1rem; width: 120px;
    }
    button#runSim {
        background: #00ffcc; color: #000; border: none; padding: 10px 25px;
        border-radius: 999px; font-family: 'Orbitron', sans-serif; font-weight: bold;
        cursor: pointer; transition: all 0.3s ease; height: 42px;
    }
    button#runSim:hover { background: #fff; box-shadow: 0 0 15px #00ffcc; }

    .chart-container {
        margin-top: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <div class="hero">
    <h1 data-text="Homework 11">Homework 11</h1>
    <h2>The Wiener Process & Stochastic Calculus</h2>
    <p class="subtitle">Gaia Diodati – Statistics Course</p>
  </div>

  <section class="content-section">
    
    <div class="post-card">
      <h2>1. The Continuum Limit: Donsker's Theorem</h2>
      <p>
        In our journey through stochastic processes, we started with the simple <i class="key-definition">Random Walk</i>, where time increments ($\Delta t$) and space steps ($\Delta x$) were discrete. The <b>Brownian Motion</b> (or Wiener Process, $W_t$) is the limiting object of a symmetric random walk as these increments shrink to zero.
      </p>
      <p>
        To ensure a non-trivial limit (where the path doesn't flatten to a straight line or explode to infinity), we must scale time and space specifically. According to the **Central Limit Theorem** and **Donsker's Invariance Principle**, we must set the spatial step size $\Delta x$ proportional to the square root of the time step:
      </p>
      <p style="text-align: center; font-family: 'Orbitron', sans-serif; font-size: 1.3rem; color: #00ffcc;">
        $$\Delta x = \sigma \sqrt{\Delta t}$$
      </p>
      <p>
        This scaling ensures that the variance remains finite ($Var(W_t) = t$). If we used $\Delta x \propto \Delta t$, the variance would vanish; if $\Delta x$ were constant, it would diverge. This $\sqrt{dt}$ term is the hallmark of **Stochastic Calculus** and leads to the unique properties of Itô integrals.
      </p>
    </div>

    <div class="post-card">
      <h2>2. Generating Gaussian Noise: The Box-Muller Transform</h2>
      <p>
        To simulate Brownian Motion, we need increments $dW \sim \mathcal{N}(0, dt)$. However, computers generate **Uniform** random numbers $U \sim (0, 1)$. How do we transform Uniform chaos into Gaussian order?
      </p>
      <p>
        The <i class="key-definition">Box-Muller Transform</i> is an elegant solution based on <b>polar coordinates</b>. If we take two independent samples $U_1, U_2$ from a uniform distribution, we can interpret them as coordinates in a 2D plane. By transforming them into a radius $R$ and an angle $\Theta$:
      </p>
      <ul>
        <li>$R = \sqrt{-2 \ln U_1}$ (derived from the exponential distribution of squared radius)</li>
        <li>$\Theta = 2\pi U_2$ (uniformly distributed angle)</li>
      </ul>
      <p>
        We obtain two independent Standard Normal variables $Z_0$ and $Z_1$:
      </p>
      <p style="text-align: center; font-family: 'Orbitron', sans-serif; font-size: 1.2rem; color: #00ffcc;">
        $$Z_0 = \sqrt{-2 \ln U_1} \cos(2\pi U_2)$$
      </p>
      <p>
        We use this algorithm in the simulation below to generate the "shocks" that drive the Brownian path.
      </p>
    </div>

    <div class="post-card">
      <h2>3. Brownian Motion Simulation</h2>
      <p>
        The graph below generates trajectories of a Wiener Process $W_t$. Notice the **fractal nature** of the paths: no matter how much you zoom in, the path remains jagged (nowhere differentiable). This is a direct consequence of the infinite variation of the process.
      </p>
      <p style="text-align: center; font-size: 1.1rem; color: #ffaa00;">
        $$W_{t+\Delta t} = W_t + \sigma \sqrt{\Delta t} \cdot Z, \quad Z \sim \mathcal{N}(0, 1)$$
      </p>

      <div class="controls">
        <div class="control-group">
            <label>Trajectories ($m$):</label>
            <input type="number" id="numPaths" value="20" min="1" max="100">
        </div>
        <div class="control-group">
            <label>Time ($T$):</label>
            <input type="number" id="timeT" value="1.0" step="0.1" min="0.1">
        </div>
        <div class="control-group">
            <label>Steps ($n$):</label>
            <input type="number" id="numSteps" value="1000" min="100" max="5000">
        </div>
        <button id="runSim" onclick="runSimulation()">Generate Paths</button>
      </div>

      <div class="chart-container">
        <canvas id="brownianChart"></canvas>
      </div>
    </div>

    <div class="post-card">
      <h2>4. Mathematical Properties of the Wiener Process</h2>
      <p>
        The simulated process $W_t$ satisfies three fundamental mathematical definitions that define the **Standard Brownian Motion**:
      </p>
      <ul>
        <li>
            <i class="key-definition">W(0) = 0</i>: The process starts at the origin almost surely.
        </li>
        <li>
            <i class="key-definition">Independent Increments</i>: The change $W_t - W_s$ is independent of the past (Markov Property). This implies the system has no "memory" of how it reached the current state.
        </li>
        <li>
            <i class="key-definition">Gaussian Increments</i>: For any $0 \le s < t$, the increment is normally distributed:
            $$W_t - W_s \sim \mathcal{N}(0, t-s)$$
        </li>
      </ul>
      <p>
        Furthermore, $W_t$ is a <i class="key-definition">Martingale</i>. This means the best prediction for the future value, given the present, is simply the current value ($E[W_{t+s} | \mathcal{F}_t] = W_t$). This property makes it the foundation for fair pricing models in finance (like Black-Scholes).
      </p>
    </div>

    <div class="post-card">
      <h2>5. The Stochastic Journey</h2>
      <p>
        By culminating in the <b>Brownian Motion</b>, we have bridged the gap between discrete coin flips and the continuous mathematics used to model stock markets, particle physics, and complex system errors. The transition from <i class="key-definition">Bernoulli</i> to <i class="key-definition">Poisson</i> to <i class="key-definition">Gaussian</i> is the backbone of modern stochastic calculus.
      </p>
    </div>

  </section>

  <script>
    let brownianChart = null;

    // --- 1. BOX-MULLER IMPLEMENTATION (Math.random -> Normal Distribution) ---
    function boxMuller() {
        let u = 0, v = 0;
        while(u === 0) u = Math.random(); // Avoid log(0)
        while(v === 0) v = Math.random();
        
        // Return only one of the pair for efficiency in sequential generation
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // --- 2. BROWNIAN PATH GENERATOR (Discrete Approximation) ---
    function generateBrownianPath(T, n) {
        const dt = T / n;       // Time step size
        const sqrt_dt = Math.sqrt(dt); // Scaling factor for variance
        
        const path = [{x: 0, y: 0}]; // Start at t=0, W=0
        let currentW = 0;
        let currentT = 0;
        
        for (let i = 0; i < n; i++) {
            currentT += dt;
            const dW = sqrt_dt * boxMuller(); // The normal jump
            currentW += dW;
            
            // Optimization: Don't push every single point if n is huge to save rendering
            // For n=1000 it is fine, but for n=10000 we might skip some.
            path.push({x: currentT, y: currentW});
        }
        return path;
    }

    // --- 3. SIMULATION & RENDERING ---
    function runSimulation() {
        const numPaths = parseInt(document.getElementById('numPaths').value);
        const T = parseFloat(document.getElementById('timeT').value);
        const n = parseInt(document.getElementById('numSteps').value);
        
        const ctx = document.getElementById('brownianChart').getContext('2d');
        if (brownianChart) brownianChart.destroy();

        const datasets = [];

        for(let i = 0; i < numPaths; i++) {
            const data = generateBrownianPath(T, n);
            const color = getRandomColor();
            
            datasets.push({
                label: `Path ${i+1}`,
                data: data,
                borderColor: color,
                borderWidth: 1,
                fill: false,
                pointRadius: 0, // Continuous line effect
                tension: 0      // Brownian motion is jagged, no smoothing!
            });
        }

        brownianChart = new Chart(ctx, {
            type: 'line',
            data: { datasets: datasets },
            options: {
                responsive: true,
                animation: false, // Disable animation for instant generation of 1000+ points
                interaction: {
                    mode: 'nearest',
                    intersect: false
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Wiener Process Simulations (T=${T}, n=${n})`,
                        color: '#ffd966',
                        font: { size: 16, family: 'Orbitron' }
                    },
                    legend: { display: false },
                    tooltip: { enabled: false } // Disable tooltips for performance on dense graphs
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: { display: true, text: 'Time (t)', color: '#ffcc00' },
                        grid: { color: 'rgba(255, 204, 0, 0.1)' },
                        ticks: { color: '#fff3cc' },
                        max: T
                    },
                    y: {
                        title: { display: true, text: 'W(t)', color: '#00ffcc' },
                        grid: { color: 'rgba(0, 255, 204, 0.1)' },
                        ticks: { color: '#fff3cc' }
                    }
                }
            }
        });
    }

    function getRandomColor() {
        // Generates bright, neon-like colors visible on dark backgrounds
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 80%, 60%)`;
    }

    // --- CANVAS BACKGROUND ---
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    const points = [];
    const numPoints = 100;

    function initPoints() {
      points.length = 0; 
      for (let i = 0; i < numPoints; i++) {
        points.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.6,
          vy: (Math.random() - 0.5) * 0.6
        });
      }
    }
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initPoints();
    }
    resizeCanvas(); 
    window.addEventListener('resize', resizeCanvas);

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        p1.x += p1.vx; p1.y += p1.vy;
        if (p1.x < 0 || p1.x > canvas.width) p1.vx *= -1;
        if (p1.y < 0 || p1.y > canvas.height) p1.vy *= -1;
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#ffcc00';
        ctx.fill();
      }
      requestAnimationFrame(draw);
    }
    draw();
    
    // Start Simulation on Load
    document.addEventListener('DOMContentLoaded', runSimulation);

  </script>
</body>
</html>